<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SPH Chat - True Token Streaming Test</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css">
  <style>
    body {
      padding: 20px;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    .message {
      padding: 10px 15px;
      border-radius: 8px;
      margin-bottom: 10px;
    }
    .user {
      background-color: #e9f5ff;
      align-self: flex-end;
    }
    .assistant {
      background-color: #f5f5f5;
      align-self: flex-start;
    }
    .cursor {
      display: inline-block;
      width: 2px;
      height: 1em;
      background-color: #333;
      animation: blink 1s infinite;
      vertical-align: middle;
      margin-left: 2px;
    }
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }
    .message-container {
      display: flex;
      flex-direction: column;
    }
    #comparison {
      display: flex;
      gap: 20px;
    }
    .stream-container {
      flex: 1;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 8px;
    }
    h3 {
      text-align: center;
      margin-bottom: 15px;
    }
    code {
      font-family: monospace;
      background-color: #f0f0f0;
      padding: 2px 4px;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1 class="text-center my-4">SPH Chat - True Token Streaming Comparison</h1>
    
    <div class="row mb-4">
      <div class="col-md-8 offset-md-2">
        <div class="card">
          <div class="card-header bg-primary text-white">
            Test Configuration
          </div>
          <div class="card-body">
            <div class="mb-3">
              <label for="chatbotId" class="form-label">Chatbot ID:</label>
              <input type="number" class="form-control" id="chatbotId" value="30">
            </div>
            <div class="mb-3">
              <label for="message" class="form-label">Your message:</label>
              <textarea class="form-control" id="message" rows="2" placeholder="Type your message...">What are the main project milestones?</textarea>
            </div>
            <div class="d-grid">
              <button id="sendButton" class="btn btn-primary">Send to Both Endpoints</button>
            </div>
            <div class="mt-2 d-flex justify-content-between">
              <div class="form-check">
                <input class="form-check-input" type="checkbox" value="" id="showCursor" checked>
                <label class="form-check-label" for="showCursor">
                  Show blinking cursor
                </label>
              </div>
              <button id="clearButton" class="btn btn-sm btn-outline-secondary">Clear Results</button>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <div id="comparison" class="mb-5">
      <div class="stream-container">
        <h3>Regular Endpoint with Chunking<br><small class="text-muted">/api/chatbots/:id/chat?stream=true</small></h3>
        <div id="regularMessages" class="message-container"></div>
        <div class="mt-2">
          <strong>Timing:</strong> <span id="regularTiming">-</span>
        </div>
      </div>
      
      <div class="stream-container">
        <h3>True Token Streaming<br><small class="text-muted">/api/chatbots/:id/stream</small></h3>
        <div id="trueStreamMessages" class="message-container"></div>
        <div class="mt-2">
          <strong>Timing:</strong> <span id="streamTiming">-</span>
        </div>
      </div>
    </div>
    
    <div class="row">
      <div class="col-md-8 offset-md-2">
        <div class="card">
          <div class="card-header bg-info text-white">
            Performance Statistics (Latest Test)
          </div>
          <div class="card-body">
            <div class="row">
              <div class="col-md-6">
                <h5>Regular Endpoint</h5>
                <ul id="regularStats" class="list-group list-group-flush">
                  <li class="list-group-item">First token: <span id="regularFirstToken">-</span></li>
                  <li class="list-group-item">Total response time: <span id="regularTotalTime">-</span></li>
                  <li class="list-group-item">Response size: <span id="regularSize">-</span></li>
                </ul>
              </div>
              <div class="col-md-6">
                <h5>True Streaming Endpoint</h5>
                <ul id="streamStats" class="list-group list-group-flush">
                  <li class="list-group-item">First token: <span id="streamFirstToken">-</span></li>
                  <li class="list-group-item">Total response time: <span id="streamTotalTime">-</span></li>
                  <li class="list-group-item">Response size: <span id="streamSize">-</span></li>
                </ul>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const sendButton = document.getElementById('sendButton');
      const clearButton = document.getElementById('clearButton');
      const chatbotIdInput = document.getElementById('chatbotId');
      const messageInput = document.getElementById('message');
      const regularMessagesContainer = document.getElementById('regularMessages');
      const trueStreamMessagesContainer = document.getElementById('trueStreamMessages');
      const showCursorCheckbox = document.getElementById('showCursor');
      
      // Stats elements
      const regularFirstToken = document.getElementById('regularFirstToken');
      const regularTotalTime = document.getElementById('regularTotalTime');
      const regularSize = document.getElementById('regularSize');
      const streamFirstToken = document.getElementById('streamFirstToken');
      const streamTotalTime = document.getElementById('streamTotalTime');
      const streamSize = document.getElementById('streamSize');
      const regularTiming = document.getElementById('regularTiming');
      const streamTiming = document.getElementById('streamTiming');
      
      // Helper function to format time difference
      function formatTimeDiff(start, end) {
        const diff = end - start;
        return `${diff}ms`;
      }
      
      // Send message to both regular and streaming endpoints
      sendButton.addEventListener('click', async function() {
        sendButton.disabled = true;
        
        const chatbotId = chatbotIdInput.value;
        const message = messageInput.value.trim();
        
        if (!chatbotId || !message) {
          alert('Please enter both a chatbot ID and a message.');
          sendButton.disabled = false;
          return;
        }
        
        // Clear previous messages
        regularMessagesContainer.innerHTML = '';
        trueStreamMessagesContainer.innerHTML = '';
        
        // Add user message to both containers
        const userMessageRegular = document.createElement('div');
        userMessageRegular.className = 'message user';
        userMessageRegular.textContent = message;
        regularMessagesContainer.appendChild(userMessageRegular);
        
        const userMessageStream = document.createElement('div');
        userMessageStream.className = 'message user';
        userMessageStream.textContent = message;
        trueStreamMessagesContainer.appendChild(userMessageStream);
        
        // Create assistant message containers
        const assistantMessageRegular = document.createElement('div');
        assistantMessageRegular.className = 'message assistant';
        regularMessagesContainer.appendChild(assistantMessageRegular);
        
        const assistantMessageStream = document.createElement('div');
        assistantMessageStream.className = 'message assistant';
        trueStreamMessagesContainer.appendChild(assistantMessageStream);
        
        // Add blinking cursor if enabled
        let cursorRegular, cursorStream;
        if (showCursorCheckbox.checked) {
          cursorRegular = document.createElement('span');
          cursorRegular.className = 'cursor';
          assistantMessageRegular.appendChild(cursorRegular);
          
          cursorStream = document.createElement('span');
          cursorStream.className = 'cursor';
          assistantMessageStream.appendChild(cursorStream);
        }
        
        // Test both endpoints
        const startTime = Date.now();
        
        // Variables to track statistics
        let regularStartTime = Date.now();
        let regularEndTime;
        let regularFirstTokenTime;
        let regularResponseSize = 0;
        
        let streamStartTime = Date.now();
        let streamEndTime;
        let streamFirstTokenTime;
        let streamResponseSize = 0;
        
        // Simulated chunked streaming test (regular endpoint)
        try {
          regularTiming.textContent = 'Waiting...';
          regularStartTime = Date.now();
          
          const response = await fetch(`/api/chatbots/${chatbotId}/chat`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              message,
              stream: true
            })
          });
          
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
          
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let content = '';
          let hasReceivedFirstToken = false;
          
          while (true) {
            const { value, done } = await reader.read();
            
            if (done) {
              break;
            }
            
            const chunk = decoder.decode(value, { stream: true });
            regularResponseSize += chunk.length;
            
            // Process the SSE data
            const lines = chunk.split('\n\n');
            for (const line of lines) {
              if (line.startsWith('data:')) {
                const data = line.substring(5);
                try {
                  const parsedData = JSON.parse(data);
                  
                  if (parsedData.content) {
                    if (!hasReceivedFirstToken) {
                      regularFirstTokenTime = Date.now();
                      hasReceivedFirstToken = true;
                    }
                    
                    content += parsedData.content;
                    assistantMessageRegular.textContent = content;
                    
                    // Re-append cursor if needed
                    if (showCursorCheckbox.checked) {
                      assistantMessageRegular.appendChild(cursorRegular);
                    }
                  }
                } catch (e) {
                  console.error('Error parsing data:', e);
                }
              }
            }
          }
          
          // Remove cursor when done
          if (showCursorCheckbox.checked && cursorRegular) {
            assistantMessageRegular.removeChild(cursorRegular);
          }
          
          regularEndTime = Date.now();
          regularTiming.textContent = `${formatTimeDiff(regularStartTime, regularEndTime)}`;
          
          // Update statistics
          if (regularFirstTokenTime) {
            regularFirstToken.textContent = formatTimeDiff(regularStartTime, regularFirstTokenTime);
          } else {
            regularFirstToken.textContent = 'N/A';
          }
          
          regularTotalTime.textContent = formatTimeDiff(regularStartTime, regularEndTime);
          regularSize.textContent = `${regularResponseSize} bytes`;
          
        } catch (error) {
          console.error('Error with regular streaming:', error);
          assistantMessageRegular.textContent = 'Error: ' + error.message;
          regularTiming.textContent = 'Failed';
        }
        
        // True token streaming test
        try {
          streamTiming.textContent = 'Waiting...';
          streamStartTime = Date.now();
          
          const response = await fetch(`/api/chatbots/${chatbotId}/stream`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              message
            })
          });
          
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
          
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let content = '';
          let hasReceivedFirstToken = false;
          
          while (true) {
            const { value, done } = await reader.read();
            
            if (done) {
              break;
            }
            
            const chunk = decoder.decode(value, { stream: true });
            streamResponseSize += chunk.length;
            
            // Process the SSE data
            const lines = chunk.split('\n\n');
            for (const line of lines) {
              if (line.startsWith('data: ')) {
                const data = line.substring(6); // Note the space after "data:"
                if (data === '[DONE]') {
                  continue;
                }
                
                if (!hasReceivedFirstToken) {
                  streamFirstTokenTime = Date.now();
                  hasReceivedFirstToken = true;
                }
                
                // For the true streaming endpoint, the data is the raw token
                content += data;
                assistantMessageStream.textContent = content;
                
                // Re-append cursor if needed
                if (showCursorCheckbox.checked) {
                  assistantMessageStream.appendChild(cursorStream);
                }
              } else if (line.includes('event: error')) {
                const errorLine = lines.find(l => l.startsWith('data: '));
                if (errorLine) {
                  const errorData = errorLine.substring(6);
                  throw new Error(JSON.parse(errorData).error || 'Unknown error');
                }
              }
            }
          }
          
          // Remove cursor when done
          if (showCursorCheckbox.checked && cursorStream) {
            assistantMessageStream.removeChild(cursorStream);
          }
          
          streamEndTime = Date.now();
          streamTiming.textContent = `${formatTimeDiff(streamStartTime, streamEndTime)}`;
          
          // Update statistics
          if (streamFirstTokenTime) {
            streamFirstToken.textContent = formatTimeDiff(streamStartTime, streamFirstTokenTime);
          } else {
            streamFirstToken.textContent = 'N/A';
          }
          
          streamTotalTime.textContent = formatTimeDiff(streamStartTime, streamEndTime);
          streamSize.textContent = `${streamResponseSize} bytes`;
          
        } catch (error) {
          console.error('Error with true streaming:', error);
          assistantMessageStream.textContent = 'Error: ' + error.message;
          streamTiming.textContent = 'Failed';
        }
        
        sendButton.disabled = false;
      });
      
      // Clear results
      clearButton.addEventListener('click', function() {
        regularMessagesContainer.innerHTML = '';
        trueStreamMessagesContainer.innerHTML = '';
        regularFirstToken.textContent = '-';
        regularTotalTime.textContent = '-';
        regularSize.textContent = '-';
        streamFirstToken.textContent = '-';
        streamTotalTime.textContent = '-';
        streamSize.textContent = '-';
        regularTiming.textContent = '-';
        streamTiming.textContent = '-';
      });
    });
  </script>
</body>
</html>